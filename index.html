<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas App Engine</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { 
            --accent: #ff9800; 
            --bg-overlay: rgba(15, 15, 15, 0.96); 
            --border: #333; 
            --text-dim: #888; 
            --error: #ff4444; 
        }
        body, html { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #000; 
        }
        canvas { 
            display: block; 
            cursor: crosshair; 
        }
        #debug-overlay { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            width: 256px; 
            max-height: 85vh; 
            overflow-y: auto; 
            background: var(--bg-overlay); 
            padding: 15px; 
            font-family: 'Ubuntu Mono', monospace; 
            border: 1px solid var(--border); 
            display: none; 
            z-index: 100; 
            color: #eee; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); 
        }
        #mouse-tracker { 
            position: absolute; 
            background: var(--bg-overlay); 
            border: 1px solid var(--border); 
            color: var(--accent); 
            padding: 4px 8px; 
            font-family: 'Ubuntu Mono', monospace; 
            font-size: 12px; 
            pointer-events: none; 
            display: none; 
            z-index: 101; 
            white-space: nowrap; 
            transform: translate(15px, 15px); 
        }
        #stats-display { 
            font-size: 16px; 
            margin-bottom: 15px; 
            padding-bottom: 10px; 
            border-bottom: 1px solid var(--border); 
            color: var(--accent); 
        }
        .control-group { 
            margin-bottom: 12px; 
            display: flex; 
            flex-direction: column; 
            gap: 5px; 
        }
        .slider-row, .color-header-row { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            font-size: 13px; 
        }
        .slider-row input[type="range"] { 
            flex-grow: 1; 
            accent-color: var(--accent); 
            cursor: pointer; 
        }
        .val-display { 
            color: var(--accent); 
            width: 45px; 
            text-align: right; 
        }
        .limit-label { 
            color: var(--text-dim); 
            width: 25px; 
            font-size: 11px; 
        }
        input[type="text"], input[type="color"], input[type="checkbox"] { 
            background: #111; 
            border: 1px solid var(--border); 
            color: var(--accent); 
            font-family: 'Ubuntu Mono', monospace; 
            padding: 2px 5px; 
        }
        input[type="color"] { 
            padding: 0; 
            height: 25px; 
            width: 50px; 
            cursor: pointer; 
        }
        input.invalid { 
            border-color: var(--error) !important; 
            color: var(--error) !important; 
        }
        button { 
            background: #222; 
            color: var(--accent); 
            border: 1px solid var(--border); 
            padding: 8px; 
            cursor: pointer; 
            font-family: 'Ubuntu Mono', monospace; 
            font-weight: bold; 
            width: 100%; 
            margin-top: 5px; 
            transition: 0.2s; 
        }
        button:hover { 
            background: var(--accent); 
            color: #000; 
        }
        button.danger { 
            color: #ff4444; 
            border-color: #442222; 
        }
        .category-header { 
            cursor: pointer; 
            color: var(--accent); 
            border-bottom: 1px solid var(--border); 
            padding-bottom: 3px; 
            margin: 15px 0 8px 0; 
            font-size: 14px; 
            font-weight: bold; 
            user-select: none; 
        }
    </style>
</head>
<body>
<div id="debug-overlay">
    <div id="stats-display">FPS: 0 | DT: 0.00ms</div>
    <div id="controls-container"></div>
</div>
<div id="mouse-tracker">X: 0 Y: 0</div>
<canvas id="mainCanvas"></canvas>
<script src="app.js"></script>
<script>
const DEFAULT_CONFIG = { 
    fps: 60, 
    showDebug: false, 
    cameraZoom: 1.0, 
    cameraOffX: 0, 
    cameraOffY: 0, 
    zoomMin: 0.1, 
    zoomMax: 5.0, 
    zoomStep: 0.1, 
    bgColor: '#121212', 
    bgAlpha: 1.0, 
    gridColor: '#202020', 
    gridAlpha: 0.5, 
    showGrid: true, 
    axisColor: '#ffffff', 
    axisAlpha: 0.2, 
    showAxis: true 
};
const DEFAULT_APP_DATA = {};
let CONFIG = { ...DEFAULT_CONFIG };
let APP_DATA = { ...DEFAULT_APP_DATA };
let UI_STATE = { collapsed: {} };
const state = { 
    canvas: null, 
    ctx: null, 
    width: 0, 
    height: 0, 
    lastTime: performance.now(), 
    frameTimes: [], 
    avgFps: 0, 
    categories: {}, 
    mouseX: 0, 
    mouseY: 0, 
    rawMouseX: 0, 
    rawMouseY: 0, 
    isDragging: false, 
    isPanning: false, 
    isShiftDown: false, 
    lastMousePos: { x: 0, y: 0 }, 
    lastPanPos: { x: 0, y: 0 },
    dt: 0 
};
function toRGBA(hex, alpha) { 
    const r = parseInt(hex.slice(1, 3), 16); 
    const g = parseInt(hex.slice(3, 5), 16); 
    const b = parseInt(hex.slice(5, 7), 16); 
    return `rgba(${r}, ${g}, ${b}, ${alpha})`; 
}
function resetCamera() { 
    CONFIG.cameraZoom = DEFAULT_CONFIG.cameraZoom; 
    CONFIG.cameraOffX = DEFAULT_CONFIG.cameraOffX; 
    CONFIG.cameraOffY = DEFAULT_CONFIG.cameraOffY; 
    if (CONFIG.showDebug) frameworkSetupUI(); 
    saveToDisk(); 
}
function getCategory(name) { 
    if (state.categories[name]) return state.categories[name]; 
    if (UI_STATE.collapsed[name] === undefined) UI_STATE.collapsed[name] = false; 
    const container = document.getElementById('controls-container'); 
    const wrapper = document.createElement('div'); 
    const header = document.createElement('div'); 
    header.className = 'category-header'; 
    header.textContent = UI_STATE.collapsed[name] ? `[+] ${name.toUpperCase()}` : `[-] ${name.toUpperCase()}`; 
    const content = document.createElement('div'); 
    content.style.display = UI_STATE.collapsed[name] ? 'none' : 'block'; 
    header.onclick = () => { 
        const isHidden = content.style.display === 'none'; 
        content.style.display = isHidden ? 'block' : 'none'; 
        header.textContent = isHidden ? `[-] ${name.toUpperCase()}` : `[+] ${name.toUpperCase()}`; 
        UI_STATE.collapsed[name] = !isHidden; 
        saveToDisk(); 
    }; 
    wrapper.appendChild(header); 
    wrapper.appendChild(content); 
    container.appendChild(wrapper); 
    state.categories[name] = content; 
    return content; 
}
function addColorWithAlpha(cat, label, currentHex, currentAlpha, cb) { 
    const p = getCategory(cat); 
    const div = document.createElement('div'); 
    div.className = 'control-group'; 
    const row1 = document.createElement('div'); 
    row1.className = 'color-header-row'; 
    const labelEl = document.createElement('label'); 
    labelEl.style.cssText = 'font-size:12px; flex-grow:1'; 
    labelEl.textContent = label; 
    const cp = document.createElement('input'); 
    cp.type = 'color'; 
    cp.value = currentHex; 
    row1.appendChild(labelEl); 
    row1.appendChild(cp); 
    const row2 = document.createElement('div'); 
    row2.className = 'slider-row'; 
    const aspan = document.createElement('span'); 
    aspan.className = 'limit-label'; 
    aspan.textContent = 'A'; 
    const as = document.createElement('input'); 
    as.type = 'range'; 
    as.min = '0'; 
    as.max = '1'; 
    as.step = '0.01'; 
    as.value = currentAlpha; 
    const ad = document.createElement('span'); 
    ad.className = 'val-display'; 
    ad.textContent = currentAlpha.toFixed(2); 
    row2.appendChild(aspan); 
    row2.appendChild(as); 
    row2.appendChild(ad); 
    const update = () => { 
        const h = cp.value; 
        const a = parseFloat(as.value); 
        ad.textContent = a.toFixed(2); 
        cb(h, a); 
        saveToDisk(); 
    }; 
    cp.oninput = update; 
    as.oninput = update; 
    div.appendChild(row1); 
    div.appendChild(row2); 
    p.appendChild(div); 
}
function addNumberInput(cat, l, val, min, max, cb) { 
    const p = getCategory(cat); 
    const div = document.createElement('div'); 
    div.className = 'control-group'; 
    const labelEl = document.createElement('label'); 
    labelEl.style.fontSize = '12px'; 
    labelEl.textContent = `${l} (${min}-${max})`; 
    const input = document.createElement('input'); 
    input.type = 'text'; 
    input.value = val; 
    input.style.width = '100%'; 
    input.style.boxSizing = 'border-box'; 
    input.oninput = (e) => { 
        const num = parseFloat(e.target.value); 
        if (!isNaN(num) && num >= min && num <= max) { 
            input.classList.remove('invalid'); 
            cb(num); 
            saveToDisk(); 
        } else { 
            input.classList.add('invalid'); 
        } 
    }; 
    div.appendChild(labelEl); 
    div.appendChild(input); 
    p.appendChild(div); 
}
function addSlider(cat, label, min, max, val, step, cb) { 
    const p = getCategory(cat); 
    const div = document.createElement('div'); 
    div.className = 'control-group'; 
    const labelEl = document.createElement('label'); 
    labelEl.style.fontSize = '12px'; 
    labelEl.textContent = label; 
    const row = document.createElement('div'); 
    row.className = 'slider-row'; 
    const minL = document.createElement('span'); 
    minL.className = 'limit-label'; 
    minL.textContent = min; 
    const input = document.createElement('input'); 
    input.type = 'range'; 
    input.min = min; 
    input.max = max; 
    input.step = step; 
    input.value = val; 
    const maxL = document.createElement('span'); 
    maxL.className = 'limit-label'; 
    maxL.textContent = max; 
    const disp = document.createElement('span'); 
    disp.className = 'val-display'; 
    disp.textContent = val; 
    input.oninput = (e) => { 
        const v = parseFloat(e.target.value); 
        disp.textContent = step >= 1 ? v : v.toFixed(2); 
        cb(v); 
        saveToDisk(); 
    }; 
    row.appendChild(minL); 
    row.appendChild(input); 
    row.appendChild(maxL); 
    row.appendChild(disp); 
    div.appendChild(labelEl); 
    div.appendChild(row); 
    p.appendChild(div); 
}
function addCheckbox(cat, l, chk, cb) { 
    const p = getCategory(cat); 
    const div = document.createElement('div'); 
    div.className = 'control-group'; 
    div.style.flexDirection = 'row'; 
    div.style.justifyContent = 'space-between'; 
    const labelEl = document.createElement('label'); 
    labelEl.style.fontSize = '12px'; 
    labelEl.textContent = l; 
    const input = document.createElement('input'); 
    input.type = 'checkbox'; 
    input.checked = chk; 
    input.onchange = (e) => { 
        cb(e.target.checked); 
        saveToDisk(); 
    }; 
    div.appendChild(labelEl); 
    div.appendChild(input); 
    p.appendChild(div); 
}
function addTextBox(cat, l, val, cb) { 
    const p = getCategory(cat); 
    const div = document.createElement('div'); 
    div.className = 'control-group'; 
    const labelEl = document.createElement('label'); 
    labelEl.style.fontSize = '12px'; 
    labelEl.textContent = l; 
    const input = document.createElement('input'); 
    input.type = 'text'; 
    input.value = val; 
    input.style.width = '100%'; 
    input.style.boxSizing = 'border-box'; 
    input.oninput = (e) => { 
        cb(e.target.value); 
        saveToDisk(); 
    }; 
    div.appendChild(labelEl); 
    div.appendChild(input); 
    p.appendChild(div); 
}
function addButton(cat, l, onClick, danger = false) { 
    const p = getCategory(cat); 
    const btn = document.createElement('button'); 
    if (danger) btn.className = 'danger'; 
    btn.textContent = l; 
    btn.onclick = onClick; 
    p.appendChild(btn); 
}
function frameworkInit() { 
    state.canvas = document.getElementById('mainCanvas'); 
    state.ctx = state.canvas.getContext('2d'); 
    loadFromDisk(); 
    frameworkResize(); 
    setupEventListeners(); 
    appInit();
    frameworkSetupUI(); 
    updateDebugVisibility(); 
    
    requestAnimationFrame(frameworkLoop); 
}
function frameworkSetupUI() { 
    state.categories = {}; 
    const container = document.getElementById('controls-container'); 
    container.textContent = ''; 
    appSetupUI(); 
    addCheckbox('Canvas', 'Show Grid', CONFIG.showGrid, v => CONFIG.showGrid = v); 
    addCheckbox('Canvas', 'Show Axis', CONFIG.showAxis, v => CONFIG.showAxis = v); 
    addColorWithAlpha('Canvas', 'Background', CONFIG.bgColor, CONFIG.bgAlpha, (h, a) => { 
        CONFIG.bgColor = h; 
        CONFIG.bgAlpha = a; 
    }); 
    addColorWithAlpha('Canvas', 'Grid Color', CONFIG.gridColor, CONFIG.gridAlpha, (h, a) => { 
        CONFIG.gridColor = h; 
        CONFIG.gridAlpha = a; 
    }); 
    addColorWithAlpha('Canvas', 'Axis Color', CONFIG.axisColor, CONFIG.axisAlpha, (h, a) => { 
        CONFIG.axisColor = h; 
        CONFIG.axisAlpha = a; 
    }); 
    addSlider('Canvas', 'Zoom', CONFIG.zoomMin, CONFIG.zoomMax, CONFIG.cameraZoom, CONFIG.zoomStep, v => CONFIG.cameraZoom = v); 
    addSlider('System', 'Target FPS', 1, 144, CONFIG.fps, 1, v => CONFIG.fps = v); 
    addButton('Misc', 'ðŸ  HOME VIEW (Home Key)', () => resetCamera()); 
    addButton('Misc', 'âš ï¸ RESET APP', () => { 
        if(confirm("Clear all data and refresh?")) { 
            localStorage.clear(); 
            location.reload(); 
        } 
    }, true); 
}
function updateDebugVisibility() { 
    document.getElementById('debug-overlay').style.display = CONFIG.showDebug ? 'block' : 'none'; 
    document.getElementById('mouse-tracker').style.display = CONFIG.showDebug ? 'block' : 'none'; 
}
function saveToDisk() { 
    localStorage.setItem('canvas_app_master', JSON.stringify({ config: CONFIG, ui: UI_STATE, appData: APP_DATA })); 
}
function loadFromDisk() { 
    const saved = localStorage.getItem('canvas_app_master'); 
    if (saved) { 
        const data = JSON.parse(saved); 
        CONFIG = { ...DEFAULT_CONFIG, ...data.config }; 
        UI_STATE = { ...UI_STATE, ...data.ui }; 
        APP_DATA = { ...DEFAULT_APP_DATA, ...data.appData };
    } 
}
function getMouseWorld() {
    const worldX = ((state.lastMousePos.x - (state.width / 2)) / CONFIG.cameraZoom) - CONFIG.cameraOffX;
    const worldY = ((state.lastMousePos.y - (state.height / 2)) / CONFIG.cameraZoom) - CONFIG.cameraOffY;
    return { x: worldX, y: worldY };
}
function setupEventListeners() { 
    window.addEventListener('resize', frameworkResize); 
    window.addEventListener('keydown', (e) => { 
        const isInput = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA'; 
        if (e.key === 'Tab' && !isInput) { 
            e.preventDefault(); 
            CONFIG.showDebug = !CONFIG.showDebug; 
            updateDebugVisibility(); 
            saveToDisk(); 
        } 
        if (e.key === 'Home' && !isInput) { 
            e.preventDefault(); 
            resetCamera(); 
        } 
        if ((e.key === 'g' || e.key === 'G') && !isInput) { 
            CONFIG.showGrid = !CONFIG.showGrid; 
            CONFIG.showAxis = !CONFIG.showAxis; 
            if (CONFIG.showDebug) frameworkSetupUI(); 
            saveToDisk(); 
        } 
        if (e.key === 'Shift') { 
            state.isShiftDown = true; 
            state.canvas.style.cursor = 'grab'; 
        } 
    }); 
    window.addEventListener('keyup', (e) => { 
        if (e.key === 'Shift') { 
            state.isShiftDown = false; 
            state.canvas.style.cursor = 'crosshair'; 
        } 
    }); 
    window.addEventListener('wheel', (e) => { 
        if (state.isShiftDown) { 
            e.preventDefault(); 
            const dir = e.deltaY > 0 ? -1 : 1; 
            CONFIG.cameraZoom = Math.min(Math.max(CONFIG.cameraZoom + (dir * CONFIG.zoomStep), CONFIG.zoomMin), CONFIG.zoomMax); 
            if (CONFIG.showDebug) frameworkSetupUI(); 
            saveToDisk(); 
        } 
    }, { passive: false }); 
    window.addEventListener('mousemove', (e) => { 
        const rect = state.canvas.getBoundingClientRect(); 
        const cx = e.clientX - rect.left; 
        const cy = e.clientY - rect.top; 
        state.lastMousePos = { x: cx, y: cy }; 
        const w = getMouseWorld(); 
        state.rawMouseX = w.x; 
        state.rawMouseY = w.y; 
        const tracker = document.getElementById('mouse-tracker'); 
        tracker.style.left = `${e.clientX}px`; 
        tracker.style.top = `${e.clientY}px`; 
        tracker.textContent = `X: ${Math.round(w.x)} Y: ${Math.round(w.y)}`; 
        if (state.isPanning) { 
            CONFIG.cameraOffX += (cx - state.lastPanPos.x) / CONFIG.cameraZoom; 
            CONFIG.cameraOffY += (cy - state.lastPanPos.y) / CONFIG.cameraZoom; 
            state.lastPanPos = { x: cx, y: cy };
        } else if (state.isDragging) { 
            state.mouseX = w.x; 
            state.mouseY = w.y; 
        } 
    }); 
    state.canvas.addEventListener('mousedown', (e) => { 
        const rect = state.canvas.getBoundingClientRect(); 
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        state.lastMousePos = { x: cx, y: cy }; 
        if (e.shiftKey) { 
            state.isPanning = true; 
            state.lastPanPos = { x: cx, y: cy };
            state.canvas.style.cursor = 'grabbing'; 
        } else { 
            state.isDragging = true; 
            const w = getMouseWorld(); 
            state.mouseX = w.x; 
            state.mouseY = w.y; 
            appMouseDown(state);
        } 
    }); 
    window.addEventListener('mouseup', () => { 
        if (state.isDragging) appMouseUp(state);
        state.isDragging = false; 
        state.isPanning = false; 
        state.canvas.style.cursor = state.isShiftDown ? 'grab' : 'crosshair'; 
        saveToDisk(); 
    }); 
}
function frameworkResize() { 
    const dpr = window.devicePixelRatio || 1; 
    state.width = window.innerWidth; 
    state.height = window.innerHeight; 
    state.canvas.style.width = `${state.width}px`; 
    state.canvas.style.height = `${state.height}px`; 
    state.canvas.width = state.width * dpr; 
    state.canvas.height = state.height * dpr; 
    state.ctx.scale(dpr, dpr); 
    appResize(); 
}
function frameworkLoop(timestamp) { 
    const elapsed = timestamp - state.lastTime; 
    if (elapsed >= 1000 / CONFIG.fps) { 
        state.frameTimes.push(elapsed); 
        if (state.frameTimes.length > 60) state.frameTimes.shift(); 
        state.avgFps = Math.round(1000 / (state.frameTimes.reduce((a, b) => a + b, 0) / state.frameTimes.length)); 
        if (CONFIG.showDebug) document.getElementById('stats-display').textContent = `FPS: ${state.avgFps} | DT: ${elapsed.toFixed(2)}ms`; 
        state.lastTime = timestamp; 
        frameworkDraw(); 
    } 
    requestAnimationFrame(frameworkLoop); 
}
function frameworkDraw() { 
    const { ctx, width, height } = state; 
    const dpr = window.devicePixelRatio || 1; 
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
    ctx.fillStyle = toRGBA(CONFIG.bgColor, CONFIG.bgAlpha); 
    ctx.fillRect(0, 0, width, height); 
    ctx.translate(width / 2, height / 2); 
    ctx.scale(CONFIG.cameraZoom, CONFIG.cameraZoom); 
    ctx.translate(CONFIG.cameraOffX, CONFIG.cameraOffY); 
    const step = 50; 
    const rW = (width / 2) / CONFIG.cameraZoom; 
    const rH = (height / 2) / CONFIG.cameraZoom; 
    const L = -rW - CONFIG.cameraOffX; 
    const R = rW - CONFIG.cameraOffX; 
    const T = -rH - CONFIG.cameraOffY; 
    const B = rH - CONFIG.cameraOffY; 
    if (CONFIG.showGrid) { 
        ctx.strokeStyle = toRGBA(CONFIG.gridColor, CONFIG.gridAlpha); 
        ctx.lineWidth = 1 / CONFIG.cameraZoom; 
        ctx.beginPath(); 
        for (let y = Math.floor(T / step) * step; y <= B; y += step) { 
            ctx.moveTo(L, y); 
            ctx.lineTo(R, y); 
        } 
        for (let x = Math.floor(L / step) * step; x <= R; x += step) { 
            ctx.moveTo(x, T); 
            ctx.lineTo(x, B); 
        } 
        ctx.stroke(); 
    } 
    if (CONFIG.showAxis) { 
        ctx.strokeStyle = toRGBA(CONFIG.axisColor, CONFIG.axisAlpha); 
        ctx.lineWidth = 2 / CONFIG.cameraZoom; 
        ctx.beginPath(); 
        ctx.moveTo(L, 0); 
        ctx.lineTo(R, 0); 
        ctx.moveTo(0, T); 
        ctx.lineTo(0, B); 
        ctx.stroke(); 
    } 
    appDraw(); 
}
frameworkInit();
</script>
</body>
</html>